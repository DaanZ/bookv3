{
    "meta": {
        "title": "Fullstack Rust: The Complete Guide to Building Apps with the Rust Programming Language",
        "author": "Andrew Weiss",
        "category": "Programming",
        "publisher": "Fullstack.io",
        "pages": 320
    },
    "parts": [
        {
            "title": "Rust Programming Guide Overview",
            "body": "<b style='color: forestgreen;'>\"Fullstack Rust\"</b> by Andrew Weiss is a 2020 programming guide focused on building applications using <b style='color: forestgreen;'>Rust language</b>. The book emphasizes <b style='color: forestgreen;'>practical application development</b> and provides comprehensive <b style='color: forestgreen;'>setup instructions</b> for Rust, including <b style='color: forestgreen;'>environment configurations</b> with tools such as <b style='color: forestgreen;'>Rustup</b> and <b style='color: forestgreen;'>Cargo</b>. It introduces Rust's <b style='color: forestgreen;'>key features</b> like <b style='color: forestgreen;'>performance</b>, <b style='color: forestgreen;'>strong type system</b>, and <b style='color: forestgreen;'>memory safety</b>. The text also highlights Rust's adaptability to both <b style='color: forestgreen;'>functional</b> and <b style='color: forestgreen;'>imperative programming styles</b> while ensuring <b style='color: forestgreen;'>safety</b> and <b style='color: forestgreen;'>efficiency</b>. <b style='color: forestgreen;'>Community engagement</b>, through channels like <b style='color: forestgreen;'>Discord</b>, and learning curve considerations are also discussed."
        },
        {
            "title": "Cargo and Initial Rust Project Setup",
            "body": "<b style='color: forestgreen;'>Cargo</b> is Rust's package manager used to manage dependencies and compile code. Familiarize with `cargo new numbers` to create a new binary project, which compiles into an executable file. Use <b style='color: forestgreen;'>main.rs</b> as the entry point for binary projects, with a `main` function executed when the binary runs. When changing features, Cargo allows for smooth transitions: redefine functions or create libraries for broad compatibility. Using <b style='color: forestgreen;'>`Vec`</b> instead of arrays can allow dynamic sizing, making it easier to manage collections. This way, code evolves from simple \"Hello, World!\" examples to more complex tasks, like printing a sequence of numbers. \n\n<b style='color: forestgreen;'>Performance and Reliability</b> in Rust are balanced by design, allowing you to perform safe memory management without sacrificing speed. By integrating `println` macros and `for` loops, you can iterate over collections and print elements. Rust's flexibility regarding types and memory allocation shines through - there are several ways to pass variables and manage ownership. With <b style='color: forestgreen;'>slices</b> and vectors (`&[u8]` and `Vec<u8>`), you can manipulate data structures, making Rust adaptable for various coding situations and reflecting the language\u2019s strong emphasis on <b style='color: forestgreen;'>ownership and type inference</b> to prevent errors at compile time."
        },
        {
            "title": "Implicit Returns and Simplifying with Collect",
            "body": "In <b style='color: forestgreen;'>Rust</b>, the last expression in a function is implicitly returned unless terminated with a semicolon. If terminated with a semicolon, the function returns an empty tuple `()` instead, which could cause an error. Using <b style='color: forestgreen;'>closure</b> syntax can help avoid explicit returns. \n\nWhen rewriting `generate_sequence` with `collect`, we utilize <b style='color: forestgreen;'>Rust's generic programming</b> to simplify the code. The `collect` function is used to transform iterators into collections like vectors. You need to specify the type for `collect` to work properly due to <b style='color: forestgreen;'>Rust's type inference limitations</b>. By pattern matching the expectation with `Vec<u8>`, `collect` automatically figures out the rest."
        },
        {
            "title": "Handling Server State with Atomic Operations in Rust",
            "body": "We start by defining server state with simultaneous access in mind. <b style='color: forestgreen;'>Mutable global variables</b> can now be done safely with Rust's `<b style='color: forestgreen;'>Cell</b>` for thread-unshared data and `<b style='color: forestgreen;'>Mutex</b>` for shared mutable data. An <b style='color: forestgreen;'>atomic integer</b> like `AtomicUsize` simplifies tracking thread use. A <b style='color: forestgreen;'>static variable</b> indicates a fixed address, useful for constant data that remains throughout the program's life, such as <b style='color: forestgreen;'>server counter</b>.\n\nThe <b style='color: forestgreen;'>server ID</b> is obtained through lock-free `fetch_add`, enabling an atomic operation that increments its state only between threads. Worker threads each maintain their own <b style='color: forestgreen;'>request count</b>, using `Cell` for safe updates without shared memory concerns. `Arc` allows <b style='color: forestgreen;'>mutual ownership</b> in the <b style='color: forestgreen;'>message vector</b>, while `Mutex` ensures valid memory access."
        },
        {
            "title": "Improving Error Handling & Path Variables Integration",
            "body": "In this <b style='color: forestgreen;'>section</b>, we improved error handling in our web app. Instead of crashing with a 500 error when incorrect data was sent, like `{\"my_message\": \"hello\"}`, we created a <b style='color: forestgreen;'>custom error handler</b>. This handler sends back a <b style='color: forestgreen;'>400 status code</b> with a JSON message detailing what went wrong, improving the <b style='color: forestgreen;'>user experience</b>. We structured the error responses similarly to regular responses with fields for server ID, request count, and the error message.\n\nMoreover, we added the ability to handle <b style='color: forestgreen;'>path variables</b> via a new GET route `/lookup/{index}`. This <b style='color: forestgreen;'>lookup service</b> attempts to retrieve a message by its index number from the list of messages. We introduced a `LookupResponse` struct where the result field can be `null` if the message is not found, enhancing our API's <b style='color: forestgreen;'>functionality and robustness</b>."
        },
        {
            "title": "Module Structuring and User Handling",
            "body": "The chapter discusses the implementation of fetching a user by different keys and setting up routes to let the application respond to different web requests. <b style='color: forestgreen;'>Result Types</b> in the `models` module uses a type alias to clean up code noise, which helps keep the codebase clear and organized. The <b style='color: forestgreen;'>User Struct</b> represents the users stored in the database, and has <b style='color: forestgreen;'>traits</b> that help manage how Rust interacts with database queries. For creating a user, a <b style='color: forestgreen;'>transaction</b> is used to ensure a smooth process, addressing SQLite's limitations for immediately retrieving new entries.\n\nA <b style='color: forestgreen;'>unique approach</b> to finding users involves using an enum, `UserKey`, to allow flexible querying by either <b style='color: forestgreen;'>unique ID or username</b>, where lifetime parameters like `<'a>` manage the safe usage of data references. For responding to web requests, <b style='color: forestgreen;'>modules and submodules</b> help in keeping the route handling organized, with each handler having clear separation in the code. Organized code use Rust's strict type and privacy system to let handlers convert input data to struct, process requests asynchronously, and manage responses cleanly without duplicating effort."
        },
        {
            "title": "Enhancing Application with Posts Feature",
            "body": "We have expanded our application to handle <b style='color: forestgreen;'>posts</b> by creating new routes and models in our Rust application using Diesel for database handling. We've introduced a <b style='color: forestgreen;'>Post</b> model with fields like *title*, *body*, and *user_id* to represent the relationship with users. To manage <b style='color: forestgreen;'>asynchronous requests</b>, we utilize the `web::block` to perform blocking database operations in a non-blocking manner. \n\nFor managing <b style='color: forestgreen;'>routes</b>, we created handlers such as `add<em style='color: forestgreen;'>post` to add a new post, `publish</em>post` to change the published status, and functions to fetch posts by user ID or all posts. We've set up the configuration to allow these routes to handle <b style='color: forestgreen;'>POST</b> and <b style='color: forestgreen;'>GET</b> requests, thus enabling users to interact with the posts functionality of our application effectively."
        },
        {
            "title": "Handling Comments & WebAssembly (Wasm) Integration",
            "body": "This section continues to build on the previous explanation of integrating database mappings with web services in a Rust-based environment, focusing on <b style='color: forestgreen;'>implementing and managing comment functionalities</b>. It describes how to set up handlers to <b style='color: forestgreen;'>add and retrieve comments</b> for posts from the database. The examples provided showcase the creation of <b style='color: forestgreen;'>routes for comments</b> in a web application, demonstrating typical HTTP requests to add comments to posts or fetch comments by specific users using `curl` commands.\n\nMoreover, the discussion moves towards explaining <b style='color: forestgreen;'>WebAssembly (Wasm)</b>, which introduces a way to run code <b style='color: forestgreen;'>alongside JavaScript</b> in browsers for performance-critical operations. Wasm acts as a <b style='color: forestgreen;'>low-level bytecode</b>, designed to be a compilation target for languages like <b style='color: forestgreen;'>Rust and C++</b>, thus <b style='color: forestgreen;'>enhancing performance</b> and <b style='color: forestgreen;'>safety</b> compared to traditional JavaScript execution. This makes it attractive for web-based applications requiring near-native execution speed."
        },
        {
            "title": "WebAssembly Module with Rust",
            "body": "<h3 style='color: forestgreen;'>Building a WebAssembly Module with Rust</h3>\n\nIn this section, we enhance our Rust program to interact with WebAssembly (Wasm) by wrapping our Rust code into a Wasm module. We used an external `<em style='color: forestgreen;'></em>greet<em style='color: forestgreen;'>wrapper` function to handle string conversion between Rust and Wasm, turning Rust string inputs into integers (pointers) and lengths suitable for Wasm, and vice versa for output. The use of <b style='color: forestgreen;'>unsafe</b> code in Rust, such as `from</em>raw_parts`, enables raw memory operations necessary for FFI. We also demonstrate using JavaScript to interface with the Wasm module, including functions for memory management like `passStringToWasm` and `getStringFromWasm` to manage string data between Wasm and JavaScript efficiently. Ultimately, we achieve calling a Wasm-exported Rust function from JavaScript that uses a string."
        },
        {
            "title": "Designing a Flexible Command-Line HTTP Client with Rust",
            "body": "The `perform` function in the client module serves as the core of the HTTP client logic, constructing the request based on various parameters and settings. <b style='color: forestgreen;'>First</b>, a new `Client` from the <b style='color: forestgreen;'>reqwest</b> library is created, and the `url` is parsed. The <b style='color: forestgreen;'>debugging log statement</b> records the parsed URL for troubleshooting. <b style='color: forestgreen;'>Next</b>, the code checks if the request should be <b style='color: forestgreen;'>multipart</b>, which affects how parameters are processed further. It <b style='color: forestgreen;'>validates</b> that the `form` flag is set appropriately when a <b style='color: forestgreen;'>form file</b> is included.\n\nThe function continues by crafting the actual HTTP request using the methods `handle<em style='color: forestgreen;'>parameters` and `handle</em>auth` to incorporate parameters and authorization settings into the request. These methods ensure the request is assembled correctly based on the application's configuration and input parameters. The <b style='color: forestgreen;'>log system</b> checks if the `info` level logs are enabled, then times the request execution to log the elapsed time for performance analysis. The result of the request is returned, completing the function's task of interfacing with the HTTP endpoint."
        },
        {
            "title": "Session Support and Struct Definition",
            "body": "To support session functionality, we start with defining a <b style='color: forestgreen;'>Session</b> struct using fields necessary for session data: *path*, *name*, *host*, *auth*, *token*, and custom *headers*. This setup allows us to perform tasks like storing session information or updating it based on a response. Additionally, we implement methods like <b style='color: forestgreen;'>add<em style='color: forestgreen;'>to</em>request</b> to add session data to outgoing requests, and <b style='color: forestgreen;'>update<em style='color: forestgreen;'>with</em>parameters</b> to modify sessions based on the request and response dynamics, enhancing our request process by enabling request session management during subsequent network requests."
        },
        {
            "title": "Procedural Macros Overview",
            "body": "<h3 style='color: forestgreen;'>Summary</h3>\nThe chapter dives into <b style='color: forestgreen;'>procedural macros</b> in Rust, which offer <b style='color: forestgreen;'>powerful code-generation capabilities</b> at compile time. Unlike <b style='color: forestgreen;'>declarative macros</b>, procedural macros can be used to perform more complex manipulations. Procedural macros come in three types: <b style='color: forestgreen;'>custom derive macros</b>, which allow automatically implementing traits; <b style='color: forestgreen;'>attribute-like macros</b>, which add custom attributes to items; and <b style='color: forestgreen;'>function-like macros</b>, which resemble function calls. \n\nThe section details implementing a <b style='color: forestgreen;'>custom derive macro</b> through a standalone crate. This approach involves manipulating syntax to lessen repetitive code, especially helpful in patterns like the <b style='color: forestgreen;'>builder pattern</b>. The builder pattern is used to construct complex objects, often enforcing certain constraints at compile-time, like ensuring necessary parameters are set before a build method is called. <b style='color: forestgreen;'>Rust's type system</b> can enforce these constraints, and the chapter illustrates how procedural macros can simplify writing boilerplate code for builders."
        },
        {
            "title": "Procedural Macro Setup",
            "body": "In this section, the code import setup for procedural macros is initiated, focusing on <b style='color: forestgreen;'>proc-macro</b> and <b style='color: forestgreen;'>proc-macro2</b> differences. The <b style='color: forestgreen;'>proc-macro</b> requires using `extern crate` even in Rust 2018 edition due to its special built-in nature, while other crates do not need this. The library's public interface is defined using <b style='color: forestgreen;'>proc<em style='color: forestgreen;'>macro</em>derive</b> with a function `builder<em style='color: forestgreen;'>derive`, which processes the input token stream into an abstract syntax tree (AST) using <b style='color: forestgreen;'>syn</b>. The function then rescales the AST for implementation in our macro code. To ensure robust error handling, <b style='color: forestgreen;'>to</em>compile_errors</b> function is used for formatting errors into compiler-friendly messages. This approach leverages result types for collective error-handling, providing user-friendly diagnostics at compile time."
        }
    ]
}