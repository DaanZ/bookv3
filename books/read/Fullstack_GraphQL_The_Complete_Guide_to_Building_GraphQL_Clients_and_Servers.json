{
    "meta": {
        "title": "Fullstack GraphQL: The Complete Guide to Building GraphQL Clients and Servers",
        "author": "Gaetano Checinski and Roy Derks",
        "category": "Programming",
        "publisher": "newline",
        "pages": 231
    },
    "parts": [
        {
            "title": "Introducing Fullstack GraphQL: The Book's Aim and Scope",
            "body": "In this book, <b style='color: forestgreen;'>Fullstack GraphQL</b>, you'll explore <b style='color: forestgreen;'>GraphQL</b> by focusing on hands-on learning through practical examples involving <b style='color: forestgreen;'>React, Node.js,</b> and <b style='color: forestgreen;'>TypeScript</b>. It emphasizes a <b style='color: forestgreen;'>problem-oriented</b> approach to familiarize you with GraphQL. The book is intended for those with a <b style='color: forestgreen;'>basic understanding</b> of JavaScript, React, and command-line tools. Throughout, you'll learn about <b style='color: forestgreen;'>GraphQL schemas</b>, <b style='color: forestgreen;'>queries</b>, and how they contrast with traditional REST APIs, tackling challenges like the <b style='color: forestgreen;'>n+1 problem</b> effectively. Essential setup instructions and helpful resources, such as community support via <b style='color: forestgreen;'>Discord</b>, accompany the learning process, ensuring smooth navigation of GraphQL's ecosystem."
        },
        {
            "title": "GraphQL Pagination for Efficient Data Transfer",
            "body": "GraphQL provides a mechanism for retrieving only a subset of data, thereby allowing more efficient network usage through pagination. Instead of retrieving every piece of data, you can request a 'page' of data and a cursor to fetch the next 'page'. This method is akin to the SQL OFFSET, letting clients fetch data in smaller, manageable bits, which can be especially useful in scenarios with large datasets, as it decreases the chance of overloading both the client and server."
        },
        {
            "title": "Integrating GraphQL with React and Node.js",
            "body": "<h3 style='color: forestgreen;'>GraphQL with React and Node.js</h3>\nIn this section, we build a dynamic app integrating GraphQL with React for the frontend and Node.js for the backend functionality. First, we use Node.js to fetch information from GitHub's GraphQL API, providing a simple demonstration that displays the user's GitHub username in the console. This involves setting up a project with the necessary dependencies and using an HTTP client like `superagent` to manage requests. Proper setup includes environmental variable handling for tokens to secure API interactions.\n\nNext, we shift to a React setup using `create-react-app` to display a list of repositories, illustrating a basic GraphQL app in the browser. This app allows the user to perform mutations, such as updating the description of repositories by interacting with input fields and buttons. The chapter emphasizes separating concerns by creating reusable hooks and components (like `Repo`) for managing associated states and effects within the React framework, promoting modular and clean code practices."
        },
        {
            "title": "Choosing and Using a GraphQL Client",
            "body": "When choosing a GraphQL client, it's essential to consider the specific requirements of your app. The <b style='color: forestgreen;'>Apollo Client</b> is highly recommended for web applications due to its extensive features and widespread community support. While <b style='color: forestgreen;'>graphql-request</b> and <b style='color: forestgreen;'>urql</b> offer lightweight options, <b style='color: forestgreen;'>Apollo Client</b> excels with features like caching, subscriptions, and middleware, which enhance development efficiency. <b style='color: forestgreen;'>Relay Modern</b> is another full-featured option, though it's more opinionated and less widely adopted outside of environments like Facebook. Choosing <b style='color: forestgreen;'>Apollo</b> can provide significant <b style='color: forestgreen;'>ecosystem advantages</b>, including tutorials and tools that support both client and server needs in GraphQL services. Additionally, <b style='color: forestgreen;'>Apollo's useQuery</b> and <b style='color: forestgreen;'>useMutation</b> hooks facilitate seamless integration with React, enabling efficient <b style='color: forestgreen;'>data fetching</b> and <b style='color: forestgreen;'>mutations</b> in applications."
        },
        {
            "title": "Building a TypeSafe GraphQL React Client App - Part 2",
            "body": "In this chapter, we're building on the existing app to improve performance and learn more about mutations. One way of enhancing performance, especially for pagination, is by <b style='color: forestgreen;'>prefetching</b> the data of the next page before the user actually navigates to it. This can make the navigation appear instantaneous because the data is already available in the cache, thanks to Apollo's built-in caching mechanism.\n\nTo implement this, you can create a <b style='color: forestgreen;'>custom hook</b> that utilizes Apollo's `useApolloClient()` to prefetch the next page's data. This ensures we're using the same Apollo client and cache when fetching queries. You execute the query with the cursor for the next page as soon as the current component is rendered, potentially using React's `useEffect` for this task. By doing this, you're essentially preloading the next set of data to make transitions seamless."
        },
        {
            "title": "Setting Up a Basic GraphQL Server",
            "body": "To set up a <b style='color: forestgreen;'>GraphQL server</b> using Express and Apollo, start by creating a <b style='color: forestgreen;'>GraphQL schema</b> using `gql` from `apollo-server-express`. Define types like `User` with fields such as `id`, `firstName`, `lastName`, and so on. Then, define the `Query` type to specify which queries the server will resolve, creating a minimal foundation for further operations like <b style='color: forestgreen;'>mutations</b> and <b style='color: forestgreen;'>subscriptions</b>.\n\nAfter defining the schema, establish <b style='color: forestgreen;'>boilerplate code</b> in `index.ts` to get the server up and running. Use the <b style='color: forestgreen;'>ApolloServer</b> from `apollo-server-express` to integrate the GraphQL functionality with an Express app. This setup includes importing the required modules and applying middleware to extend Express with GraphQL capabilities, thus enabling a functioning <b style='color: forestgreen;'>API framework</b>."
        },
        {
            "title": "Starting Your First GraphQL Server",
            "body": "To start the <b style='color: forestgreen;'>GraphQL server</b>, use the command <b style='color: forestgreen;'>`npm start`</b> which uses <b style='color: forestgreen;'>nodemon</b> to compile and run the `src/index.ts` file, making it easy to begin serving GraphQL at <b style='color: forestgreen;'>`http://localhost:4000/graphql`</b>. At this URL, you can explore your API using the <b style='color: forestgreen;'>GraphQL playground</b>, a handy tool for testing queries.\n\nInitially, the server will reply with <b style='color: forestgreen;'>mock data</b> for queries because <b style='color: forestgreen;'>mocking</b> was enabled. This means when you send the <b style='color: forestgreen;'>query</b> `{ users { id firstName lastName } }`, you'll receive an array of user objects with mock values. This setup aids in early development, allowing you to design and test the <b style='color: forestgreen;'>UI</b> even if the actual logic or data interactions are not fully implemented yet. <b style='color: forestgreen;'>Apollo Server</b> makes it straightforward to configure these mocks to return specific values for different <b style='color: forestgreen;'>GraphQL types</b>."
        },
        {
            "title": "Cursor Pagination in GraphQL",
            "body": "In this section, we learned about <b style='color: forestgreen;'>cursor pagination</b>, which allows for more efficient data retrieval compared to offset pagination. Cursor pagination focuses on getting results after a specific point (the <b style='color: forestgreen;'>cursor</b>). To use cursor pagination in GraphQL, you include parameters like `first` and `after` in your query. For instance, a query to fetch tracks would look like:\n\n```graphql\nquery {\n tracks(first: 10, after: 1) {\n title\n }\n}\n```\n\nThe <b style='color: forestgreen;'>cursor</b> is typically a unique identifier, allowing users to continue retrieving subsequent data pages more precisely. This differs from offset pagination, which assumes a fixed number of page entries, offering <b style='color: forestgreen;'>greater flexibility and control</b> over data retrieval. Moreover, using cursor pagination with <b style='color: forestgreen;'>Relay</b>, the client-side GraphQL implementation by Facebook, standardizes how you handle paginated data, although it requires specific resolver setups."
        },
        {
            "title": "Batching & Caching with DataLoader in GraphQL",
            "body": "To optimize requests to the database and manage caching, we use <b style='color: forestgreen;'>DataLoader</b> in our GraphQL server. This tool prevents redundant data fetching by batching and caching data requests. <b style='color: forestgreen;'>DataLoaders</b> collect IDs or keys during a request lifecycle, sending them together to the database, minimizing requests. Our setup includes a new DataLoader instance for fetching artist data, reducing individual calls to the database by grouping them.\n\nAdditionally, we modify resolvers to support DataLoader usage, tailoring the resolver logic to utilize these loaders instead of direct database queries. The setup demonstrates a reduction in logged database calls, indicating fewer, more efficient queries due to this batching strategy. In cases of repeated requests for the same data, DataLoader uses a simple <b style='color: forestgreen;'>Map</b> for per-request caching, further enhancing performance. Overall, DataLoader proves essential for optimizing data-fetching efficiency in GraphQL services, pairing batching with effective caching strategies for operations like fetching artist information in music-related data contexts."
        },
        {
            "title": "GraphQL Authorization with Custom Directives",
            "body": "The code example introduces how to implement <b style='color: forestgreen;'>authorization</b> in a GraphQL server using <b style='color: forestgreen;'>custom directives</b> and <b style='color: forestgreen;'>JWT validation</b>. A directive called <b style='color: forestgreen;'>@auth</b> is added to protect certain fields or mutations based on <b style='color: forestgreen;'>user roles</b> and <b style='color: forestgreen;'>authentication status</b>. This is done by defining the <b style='color: forestgreen;'>AuthDirective</b> class, which implements `visitFieldDefinition` to enforce rules like checking if a user is authenticated or if the user role matches the required role for accessing a field.\n\nIn the <b style='color: forestgreen;'>Apollo Server</b> setup, the directive is applied by importing `AuthDirective` and using it in the `schemaDirectives` configuration. A <b style='color: forestgreen;'>context</b> function is used to extract the <b style='color: forestgreen;'>JWT</b> from request headers, verify it, and add user info to the context, which is then used by the directive to determine access rights. The example also shows how you can extend this approach to add <b style='color: forestgreen;'>role-based access controls</b> for mutations using the @auth directive."
        }
    ]
}