{
    "meta": {
        "title": "Thinking Recursively",
        "author": "Eric Roberts",
        "category": "Recursion Theory",
        "publisher": "John Wiley & Sons, Inc.",
        "pages": 189
    },
    "parts": [
        {
            "title": "Preface Overview",
            "body": "The <b style='color: forestgreen;'>Preface</b> of the book <em style='color: forestgreen;'>\"Thinking Recursively\"</em> by Eric Roberts introduces the <b style='color: forestgreen;'>challenges</b> of <b style='color: forestgreen;'>teaching recursion</b> to students. Many find it <b style='color: forestgreen;'>mystical</b> and struggle to apply it, leading to difficulties in advanced courses. This book aims to <b style='color: forestgreen;'>demystify recursion</b> and is suggested as a <b style='color: forestgreen;'>supplementary text</b> in data structures courses. Students need only basic <b style='color: forestgreen;'>programming</b> skills, with examples using <b style='color: forestgreen;'>Pascal</b>. It covers <b style='color: forestgreen;'>recursion</b> from <b style='color: forestgreen;'>different angles</b> to build understanding, with <b style='color: forestgreen;'>focus areas</b> on recursive <b style='color: forestgreen;'>functions</b> and <b style='color: forestgreen;'>sorted problems</b>. The text is shaped by insights from colleagues and the author shows <b style='color: forestgreen;'>gratitude</b> to their contributions."
        },
        {
            "title": "Mathematical Foundations of Recursive Thinking",
            "body": "Chapter 2 of \"Thinking Recursively\" delves into two mathematical concepts crucial to understanding recursion: <b style='color: forestgreen;'>mathematical induction</b> and <b style='color: forestgreen;'>computational complexity</b>. <b style='color: forestgreen;'>Induction</b> is akin to recursive thinking, where a proof or solution is built on simpler cases. For instance, the sum of integers formula can be proved for <b style='color: forestgreen;'>any positive integer N</b> through induction, starting with a base case and extending via a <b style='color: forestgreen;'>hypothetical assumption</b> for N, leading to a solution for N+1. This technique involves a <b style='color: forestgreen;'>\"leap of faith\"</b>, trusting an unknown truth to establish the logical consistency of a formula or solution.\n\n<b style='color: forestgreen;'>Complexity</b> analysis provides a framework for comparing the efficiency of different algorithms by considering the number of operations needed relative to the <b style='color: forestgreen;'>problem size (N)</b>. Complexity is categorized into classes such as <b style='color: forestgreen;'>linear, quadratic</b>, and <b style='color: forestgreen;'>exponential</b>, among others. An algorithm's efficiency is expressed using <b style='color: forestgreen;'>big-O notation</b>, indicating how the time to solve a problem increases with N. For instance, <b style='color: forestgreen;'>binary search</b> is more efficient than <b style='color: forestgreen;'>linear search</b> because it reduces possibilities by factors of two, showing significant gains as N grows larger. Understanding these concepts enables programmers to design more efficient algorithms by reducing complexity bounds, leading to substantial performance improvements in large-scale problems."
        },
        {
            "title": "Recursive Functions and Their Characteristics",
            "body": "Recursive <b style='color: forestgreen;'>functions</b> and <b style='color: forestgreen;'>procedures</b> leverage recursion, but differ conceptually. <b style='color: forestgreen;'>Functions</b> return values, making them aligned with <b style='color: forestgreen;'>mathematical</b> concepts, while <b style='color: forestgreen;'>procedures</b> execute tasks based on their effects. The <b style='color: forestgreen;'>factorial</b> function (FACT) is a classic recursive example: <b style='color: forestgreen;'>FACT(N) = N * FACT(N-1)</b>, with a base case of <b style='color: forestgreen;'>0! = 1</b>. Similarly, the <b style='color: forestgreen;'>Fibonacci sequence</b> can also be expressed recursively by <b style='color: forestgreen;'>FIB(N) = FIB(N-1) + FIB(N-2)</b>, with base cases defined for <b style='color: forestgreen;'>FIB(0)</b> and <b style='color: forestgreen;'>FIB(1)</b> respectively. Recursive definitions are often more intuitively aligned with <b style='color: forestgreen;'>mathematics</b>, though they may not always yield the most <b style='color: forestgreen;'>efficient</b> computation solutions."
        },
        {
            "title": "Recursive Problem Solving: Tower of Hanoi",
            "body": "<h3 style='color: forestgreen;'>Simplifying the Hanoi Towers Problem Recursively</h3>\n\nIn the traditional <b style='color: forestgreen;'>Tower of Hanoi</b> problem, you aim to move all disks from one needle to another, following specific rules. A recursive method to solve this problem includes breaking it down into smaller subproblems:\n1. Move the top disks of the stack to a temporary needle.\n2. Move the bottom disk to the target needle.\n3. Move the smaller tower from the temporary needle to the target.\n\nA <b style='color: forestgreen;'>procedure</b>, `MOVETOWER`, effectively implements this recursive strategy by taking parameters for the number of disks and the roles of needles (start, finish, and temporary). The base case for this recursive procedure is moving a single disk, whereas the recursive case involves moving multiple disks through the subgoals described. This recursive approach allows the solution to be concise and elegant, taking advantage of <b style='color: forestgreen;'>repeated patterns</b> in solving subproblems, such as moving smaller stacks of disks."
        },
        {
            "title": "Sorting and Algorithms",
            "body": "<b style='color: forestgreen;'>Sorting</b>: This chapter explores sorting methods to arrange data in sequence, such as selection sort and merge sort. <b style='color: forestgreen;'>Selection sort</b> iteratively selects the smallest element from an unsorted list and swaps it to its correct position. This method, although intuitive, is inefficient for large datasets because its <b style='color: forestgreen;'>complexity</b> is <b style='color: forestgreen;'>O(N\u00b2)</b>. As the size increases, the time required becomes impractical due to the number of comparisons needing to be performed, growing significantly with larger data sets. \n\nOn the other hand, <b style='color: forestgreen;'>merge sort</b>, a recursive sorting algorithm, is proposed. It splits the array in half, recursively sorts each piece, then merges them back. This divide-and-conquer strategy allows for a much more efficient sort compared to selection sorting, particularly for large datasets. The chapter introduces the MERGESORT procedure within the SORT interface and explores the logic behind the merging procedure, emphasizing the efficiency gained through this recursive sorting approach."
        },
        {
            "title": "Recursive Backtracking for Maze Solving",
            "body": "In this section, we delve into <b style='color: forestgreen;'>backtracking</b> as a strategy to solve problems where multiple paths might lead to a solution or a dead-end, like in maze solving. Instead of detecting dead ends immediately, the program continues until it \"hits\" a wall or revisits a marked path. Hence, the algorithm steps back (\n<b style='color: forestgreen;'>recursion</b>), marking and unmarking steps as it attempts each possible direction at each square - north, east, south, and west. This approach, commonly known as a \"<b style='color: forestgreen;'>backtracking algorithm</b>,\" explores all potential paths systematically.\n\nFor the maze-<b style='color: forestgreen;'>solving algorithm</b>, it assesses each square as a decision (choice) point, trying each route until a solution is found or all options are exhausted. The maze solver successively marks paths with \"<b style='color: forestgreen;'>X</b>\" (walking through the maze) and returns to unmark \"X\" if a path couldn't lead to a solution. The function <b style='color: forestgreen;'>FINDPATH</b> within the algorithm handles this recursively, where each new decision branches as a recursive call exploring further until either a valid path is found or it hits a wall/backtracks to the previous choice point. Additionally, at times, one can also maintain markers on paths to potentially speed up the verification of already-proven wrong paths (case use of recursive call optimizations)."
        },
        {
            "title": "Understanding Recursive Data in Pascal",
            "body": "<h3 style='color: forestgreen;'>Recursive Data Structures in Pascal</h3>\n\nPascal is a programming language that offers flexibility with <b style='color: forestgreen;'>data representation</b>, useful for representing <b style='color: forestgreen;'>variable length strings</b>, among other things. It supports <b style='color: forestgreen;'>records</b> and <b style='color: forestgreen;'>pointers</b>, allowing programmers to create new, intricate <b style='color: forestgreen;'>data structures</b>. A <b style='color: forestgreen;'>recursive data type</b> in Pascal might include a pointer to the same type, indicated through a code like `TYPE YfRYfR = i YfRYfR;`. While this specific declaration may not be immediately useful, more complex structures can use recursive types effectively.\n\nFor example, an <b style='color: forestgreen;'>OBJECT</b> type might hold a <b style='color: forestgreen;'>DATA</b> integer and a <b style='color: forestgreen;'>LINK pointer</b>, representing a <b style='color: forestgreen;'>linked list</b>. Such linked lists can offer a way to structure variable length strings by chaining <b style='color: forestgreen;'>CELL records</b> together, where each record contains a <b style='color: forestgreen;'>character</b> and a <b style='color: forestgreen;'>link</b> to the next character. Implementing functions like <b style='color: forestgreen;'>LENGTH, WRITESTR, READSTR</b>, and <b style='color: forestgreen;'>CONCAT</b> for strings ensures that even with varied lengths, operations remain manageable. The <b style='color: forestgreen;'>MAKESTR</b> function demonstrates creating a new string by combining a character and an existing string through pointers."
        },
        {
            "title": "Insertion into a Binary Tree",
            "body": "To <b style='color: forestgreen;'>insert</b> a value into an existing binary <b style='color: forestgreen;'>tree</b>, the program checks where the value should go by comparing it to the current node. If a value is less than the current node's <b style='color: forestgreen;'>value</b>, it inserts it into the <b style='color: forestgreen;'>BEFORE</b> subtree. Conversely, a greater value goes into the <b style='color: forestgreen;'>AFTER</b> subtree. To handle <b style='color: forestgreen;'>duplicates</b>, this implementation assumes a value should only be stored once, so attempts to add duplicates are ignored.\n\nThe <b style='color: forestgreen;'>INSERTTREE</b> procedure uses <b style='color: forestgreen;'>recursive</b> calls to handle tree nodes, deciding whether to insert a <b style='color: forestgreen;'>number</b> into the current node's "
        }
    ]
}