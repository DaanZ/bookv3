{
    "meta": {
        "title": "Artificial Intelligence for Humans, Volume 2: Nature-Inspired Algorithms",
        "author": "Jeff Heaton",
        "category": "Technology",
        "publisher": "Heaton Research, Inc.",
        "pages": 203
    },
    "parts": [
        {
            "title": "Artificial Intelligence for Humans Series Overview",
            "body": "<b style='color: forestgreen;'>Artificial Intelligence for Humans</b> series by Jeff Heaton introduces AI concepts <b style='color: forestgreen;'>simply</b> for real humans, not just PhDs. The <b style='color: forestgreen;'>books offer examples</b> in multiple <b style='color: forestgreen;'>programming languages</b> and online labs to facilitate <b style='color: forestgreen;'>hands-on learning</b>. They cover topics like <b style='color: forestgreen;'>genetic algorithms</b> and <b style='color: forestgreen;'>pseudocode</b> to overcome the barrier of complex <b style='color: forestgreen;'>mathematics</b>. Dave Snell highlights Jeff's <b style='color: forestgreen;'>real-world approach</b> and <b style='color: forestgreen;'>passion</b> for AI, as he provides <b style='color: forestgreen;'>accessible</b> instruction backed by community support and resources like GitHub, ensuring practical application <b style='color: forestgreen;'>without learning a new language</b>."
        },
        {
            "title": "Understanding Euclidean Distance and RBF Networks",
            "body": "Machine learning often uses <b style='color: forestgreen;'>Euclidean distance</b> to compare two vectors of numbers. <b style='color: forestgreen;'>Equation 2</b> from Deza describes this distance between two arrays as the square root of the sum of squared differences between each element, which remains the same regardless of the direction. The <b style='color: forestgreen;'>pseudocode</b> for calculating this involves iterating through elements to find the sum of squared differences and finally taking the square root of this sum.\n\n<b style='color: forestgreen;'>Radial-Basis Function (RBF) networks</b> use input vectors to generate outputs for tasks like recognizing <b style='color: forestgreen;'>Iris species</b> with <b style='color: forestgreen;'>Gaussian functions.</b> They learn by adjusting parameters to best fit the input data, while the <b style='color: forestgreen;'>RBF</b> itself is symmetric and centered, producing a maximum value at its center. In RBF models, distances are generally measured using Euclidean distance, and the computation involves converting multidimensional inputs into a single scalar output by calculating the distance from the center."
        },
        {
            "title": "Selection Method Exploration",
            "body": "<b style='color: forestgreen;'>Tournament selection</b> mimics survival scenarios in nature where only outpacing nearby threats is necessary, offering a <em style='color: forestgreen;'>biologically plausible method</em>. I've experimented with how <b style='color: forestgreen;'>round counts</b> affect scores using a population of <em style='color: forestgreen;'>1,000 individuals</em>, showing that, notably, an <b style='color: forestgreen;'>increase in rounds</b> correlates with higher selection scores <em style='color: forestgreen;'>(median lists provided)</em>. A <em style='color: forestgreen;'>round count of five</em> serves as a reasonable trade-off, maintaining high performance without purely favoring top percentages, <em style='color: forestgreen;'>thus ensuring some diversity.</em>"
        },
        {
            "title": "Chapter 4: Genetic Programming",
            "body": "<h3 style='color: forestgreen;'>Chapter 4: Genetic Programming</h3>\n\n<b style='color: forestgreen;'>Genetic Programming</b> allows for the creation of <b style='color: forestgreen;'>evolving programs</b> to solve problems, by representing solutions as <b style='color: forestgreen;'>trees</b>. Unlike genetic algorithms, which deal with <b style='color: forestgreen;'>fixed-length solution arrays</b>, genetic programming uses <b style='color: forestgreen;'>tree structures</b> to encode solutions. This chapter explains how programs can be expressed as trees, which is an adaptable way of <b style='color: forestgreen;'>representing solutions</b> in computing. We will begin by investigating how <b style='color: forestgreen;'>mathematical expressions</b> can be organized into tree formats, providing a starting point for organizing computer programs in this way. \n\nThis form of representation offers greater flexibility and can overcome the constraints of fixed lengths in genetic algorithms, thereby allowing for more dynamic solutions. Understanding this concept is key as it forms the basis for developing better programs through <b style='color: forestgreen;'>crossover and mutation</b> of these trees."
        },
        {
            "title": "Tree Initialization Algorithms in Genetic Programming",
            "body": "The text explains <b style='color: forestgreen;'>three tree initialization algorithms</b> used in <b style='color: forestgreen;'>genetic programming</b>: <b style='color: forestgreen;'>Full Tree Initialization</b>, <b style='color: forestgreen;'>Grow Tree Initialization</b>, and <b style='color: forestgreen;'>Ramped Half-and-Half Initialization</b>. Full tree initialization creates a tree where all nodes are <b style='color: forestgreen;'>function nodes</b> until the maximum depth is reached, ensuring the tree is 'full'. Grow initialization also creates nodes but allows terminal nodes at any depth, resulting in <b style='color: forestgreen;'>asymmetrical trees</b>. <b style='color: forestgreen;'>Ramped Half-and-Half Initialization</b> combines both previous methods to generate diverse initial populations by mixing full and grow methods and varying tree depths, providing a <b style='color: forestgreen;'>wider variety</b> in the structure of the population."
        },
        {
            "title": "Evolving Trees for Equation Fitting",
            "body": "The text discusses the <b style='color: forestgreen;'>process</b> of difference <b style='color: forestgreen;'>equations</b> as evolvable <b style='color: forestgreen;'>trees</b> and the <b style='color: forestgreen;'>significance</b> of <b style='color: forestgreen;'>regression</b> to create a formula from collected data. Regression, specifically, is used to predict numeric outcomes based on given inputs. Unlike techniques like <b style='color: forestgreen;'>RBF networks</b> that are complex and lack <b style='color: forestgreen;'>explainability</b>, evolvable trees offer clarity in understanding data relationships.\n\nWithin <b style='color: forestgreen;'>genetic programming</b>, the task is to generate equations that predict <b style='color: forestgreen;'>outputs</b> like 'y' from inputs like 'x'. Training the algorithm involves iterations where current errors continuously improve. The algorithm converges towards an ideal <b style='color: forestgreen;'>solution</b>, though it might initially address complex equations that require <b style='color: forestgreen;'>simplification</b> using computer algebra techniques. This approach avoids premature simplification, keeping the potential for mutation and evolution substantial, essential for avoiding stagnation and ensuring effective outcomes."
        },
        {
            "title": "Nature-Inspired Optimization Algorithms Overview",
            "body": "<b style='color: forestgreen;'>Particle Swarm Optimization (PSO)</b> is a method to train RBF neural networks by adjusting model parameters, starting with a <b style='color: forestgreen;'>random position</b> of a particle. It uses <b style='color: forestgreen;'>particles</b> to explore high-dimensional spaces in search of an optimal solution. The algorithm updates <b style='color: forestgreen;'>personal best (pbest)</b> scores and seeks new global <b style='color: forestgreen;'>best scores</b> through iterations. Trainer settings include variables like <b style='color: forestgreen;'>velocity</b> vectors, which are crucial for movement in the PSO space.\n\n<b style='color: forestgreen;'>Ant Colony Optimization (ACO)</b> mimics ant foraging behavior and operates on both <b style='color: forestgreen;'>discrete and continuous</b> problems. Discrete ACO, often applied to the <b style='color: forestgreen;'>Traveling Salesman Problem</b>, optimizes arrangements through <b style='color: forestgreen;'>pheromone trails</b> while combating pheromone <b style='color: forestgreen;'>evaporation</b> that encourages exploration. Continuous ACO adaptively utilizes <b style='color: forestgreen;'>Gaussian kernels</b> (a series of Gaussian functions used for sampling) to sample random numbers and adjust model solutions efficiently. Both methods illustrate <b style='color: forestgreen;'>nature-inspired algorithms</b> that adapt AI models to complex data sets, achieving results in minimal iterations compared to other means."
        },
        {
            "title": "Exploring Cellular Automata and Game of Life",
            "body": "<b style='color: forestgreen;'>Conway\u2019s Game of Life</b> is a famous <b style='color: forestgreen;'>cellular automation</b> that follows four deterministic rules. Live cells die based on their neighbor's count, reproduce, or stay alive. Its patterns like \"<b style='color: forestgreen;'>Methuselahs</b>\" converge slowly, and \"<b style='color: forestgreen;'>gliders</b>\" move diagonally through phases. Multiverse viewers allow evolving unique <b style='color: forestgreen;'>cellular automata</b> using <b style='color: forestgreen;'>human-based genetic algorithms</b> (HBGA) by adjusting the 16-vector physical constants, exploring fascinating patterns. <b style='color: forestgreen;'>Merge physics</b> as cellular automata can also generate complex universes with <b style='color: forestgreen;'>unique patterns</b> like \"purple blob\" and \"red universe\" by utilizing floating-point vectors for evolving complex <b style='color: forestgreen;'>patterns</b>."
        },
        {
            "title": "Sun, Water, and Plant Circulation",
            "body": "The <b style='color: forestgreen;'>program</b> performs calculations of <b style='color: forestgreen;'>sun</b> and <b style='color: forestgreen;'>water</b> on a grid\"s height in <b style='color: forestgreen;'>two</b> passes: sunlight first, then water. <b style='color: forestgreen;'>Sunlight</b> and <b style='color: forestgreen;'>water vectors</b> decrease below <b style='color: forestgreen;'>ground level</b>, turning zero. <b style='color: forestgreen;'>Shade</b> affects sunlight, reducing energy for living cells. <b style='color: forestgreen;'>Decay</b> is determined by multiplying <b style='color: forestgreen;'>leafiness</b> (0.1). For instance, if a light vector of 0.5 crosses a cell with a leafiness of <b style='color: forestgreen;'>0.9</b>, decay equals <b style='color: forestgreen;'>0.045</b>, reducing the vector value to <b style='color: forestgreen;'>0.045</b>. Similarly, water decays. This decay accounts for shade and <b style='color: forestgreen;'>water absorption</b>, not <b style='color: forestgreen;'>circulation</b>, which distributes energy to roots and nourishment to leaves. <b style='color: forestgreen;'>Circulation</b> is illustrated in Figure <b style='color: forestgreen;'>9.5</b>.\n\nIn <b style='color: forestgreen;'>Figure 9.5: Plant Circulation</b>, energy and nourishment circulate: energy from above, nourishment from below. Living cells calculate maximum values of circulating energy and nourishment. <b style='color: forestgreen;'>Nourishment</b> = max(water vector, circulation nourishment). <b style='color: forestgreen;'>Energy</b> = max(sunlight vector, calculated energy). <b style='color: forestgreen;'>Cells die</b> if nourishment drops below a threshold. <b style='color: forestgreen;'>Circulation</b> moves in one direction: nourishment up, energy down. <b style='color: forestgreen;'>Experimentation</b> led to a balance between complexity and evolving stems/trunks. Ensuring enough <b style='color: forestgreen;'>roots</b> support plant growth was a challenge. Growth occurs if root ratio supports it. <b style='color: forestgreen;'>Root ratio</b> = sum(root nourishment) / sum(leafiness). This ensures adequate root support to the surface plant."
        }
    ]
}