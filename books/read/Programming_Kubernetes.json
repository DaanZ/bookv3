{
    "meta": {
        "title": "Programming Kubernetes",
        "author": "Michael Hausenblas and Stefan Schimanski",
        "category": "Technology / Cloud Computing",
        "publisher": "O'Reilly Media, Inc.",
        "pages": 367
    },
    "parts": [
        {
            "title": "Introduction to Programming Kubernetes",
            "body": "Programming <b style='color: forestgreen;'>Kubernetes</b> is about <b style='color: forestgreen;'>cloud-native</b> applications. This <b style='color: forestgreen;'>book</b> helps developers integrate <b style='color: forestgreen;'>Kubernetes APIs</b> into apps for <b style='color: forestgreen;'>scalability</b> and <b style='color: forestgreen;'>portability</b>. It goes beyond deploying apps by showing how to leverage <b style='color: forestgreen;'>custom resources</b> and <b style='color: forestgreen;'>controllers</b> to interact directly with APIs. Learning <b style='color: forestgreen;'>Go</b> programming is recommended as Kubernetes is written in <b style='color: forestgreen;'>Go</b>. The book prepares developers to manage both <b style='color: forestgreen;'>in-cluster</b> and <b style='color: forestgreen;'>external resources</b>. Emphasis is on <b style='color: forestgreen;'>optimistic concurrency</b>, allowing efficient operations without <b style='color: forestgreen;'>locks</b> and enabling retry mechanisms for <b style='color: forestgreen;'>distributed systems</b>. <b style='color: forestgreen;'>Resource</b> management and event-driven systems are pivotal themes."
        },
        {
            "title": "Optimistic Concurrency & Operators Overview",
            "body": "The <b style='color: forestgreen;'>resource version</b> is a critical element in <b style='color: forestgreen;'>Kubernetes</b>'s <b style='color: forestgreen;'>optimistic concurrency logic</b>. It indicates whether an object in the database, like <b style='color: forestgreen;'>etcd</b>, has been changed by another process. During update operations, if the <b style='color: forestgreen;'>resource version</b> has changed, a conflict error occurs, denoting a <b style='color: forestgreen;'>failed optimistic operation</b>. This necessitates implementing a <b style='color: forestgreen;'>retry strategy</b> in your controller as multiple actors might be modifying the state, leading to these errors being entirely normal.\n\nEnter <b style='color: forestgreen;'>Operators</b>, a concept introduced by <b style='color: forestgreen;'>CoreOS</b> in 2016, which take advantage of Kubernetes' capabilities. They are application-specific controllers that enhance Kubernetes' API to manage complex applications, automating tasks using <b style='color: forestgreen;'>domain knowledge</b>. Operators consist of <b style='color: forestgreen;'>Custom Resource Definitions (CRDs)</b> and a <b style='color: forestgreen;'>custom controller</b> to manage resources effectively. They fundamentally evolve the way operational knowledge is embedded into software, facilitating better management of stateful applications."
        },
        {
            "title": "Understanding API Machinery and REST Mapping",
            "body": "The <b style='color: forestgreen;'>API Machinery</b> repository manages the basics of Kubernetes types. A crucial concept here is <b style='color: forestgreen;'>kinds</b>, identified as <b style='color: forestgreen;'>GroupVersionKind</b> (GVK). These relate to Go types but not always to HTTP paths. For example, <b style='color: forestgreen;'>AdmissionReview</b> lacks a REST endpoint. <b style='color: forestgreen;'>Resources</b> complement this by mapping to a <b style='color: forestgreen;'>GroupVersionResource</b> (GVR), determining REST paths like /apis/apps/v1/namespace/deployments.\n\n<b style='color: forestgreen;'>RESTMapping</b> connects these, providing functions to determine the GVR for a given GVK, essential for client libraries building up HTTP paths dynamically. The <b style='color: forestgreen;'>DeferredDiscoveryRESTMapper</b>, for instance, uses server discovery info to handle this, dynamically mapping custom resources seamlessly. Meanwhile, <b style='color: forestgreen;'>Scheme</b> registers Golang types with possible GVKs, being pivotal in converting GVKs to Go types and vice versa, including managing defaults and conversions is key."
        },
        {
            "title": "Understanding Kubernetes Custom Resources and CRDs",
            "body": "In Kubernetes, custom resources (CRs) are a powerful extension to the Kubernetes API, allowing users to define custom objects without requiring complex programming logic. These CRs are declared through <b style='color: forestgreen;'>CustomResourceDefinitions (CRDs)</b>, which expose these new resource types through the Kubernetes API server. \n\nCRDs allow developers to define and manage resources that extend Kubernetes using existing GVK (Group, Version, and Kind) schema such as the 'At' kind in the example. Once CRDs are created, tools like <b style='color: forestgreen;'>kubectl</b> automatically recognize the resource and provide API discovery features that list these new resources, ensuring they're integrated and manageable within Kubernetes clusters."
        },
        {
            "title": "Code Generation and Tagging in Go",
            "body": "In this chapter, we walked through using <b style='color: forestgreen;'>Kubernetes code generators</b> to help manage custom resources, explaining the use of tags in <b style='color: forestgreen;'>Go files</b> to control the code generation. This involves setting <b style='color: forestgreen;'>global tags</b>, typically in `doc.go`, to enable functionalities across all types in a package, and using <b style='color: forestgreen;'>local tags</b> directly above type declarations for more granular control. <b style='color: forestgreen;'>deepcopy-gen</b> is used to generate deep-copy methods for types, while <b style='color: forestgreen;'>client-gen</b> and other generators help create clients, informers, and listers. We highlighted keeping your <b style='color: forestgreen;'>API documentation</b> separate from these tags to ensure clarity.\n\nFor larger projects, generating code can help maintainability and enforce consistency while reducing repetitive work, aiding the system in handling newer resources without much manual intervention. Handling more detailed generation processes, such as <b style='color: forestgreen;'>conversion and defaulting</b> for custom API servers, is also possible. Understanding these tools can greatly assist in automating and simplifying controller development. The comparison and use of different generator tags help tailor the generated code to the project's specific needs, optimizing both runtime behavior and development efficiency."
        },
        {
            "title": "Developing and Deploying Kubernetes Operators with Kubebuilder and Operator SDK",
            "body": "Kubebuilder and Operator SDK are powerful tools for developing custom Kubernetes controllers and operators. They allow you to focus on the <b style='color: forestgreen;'>business logic</b> rather than boilerplate code, facilitating easier <b style='color: forestgreen;'>development</b>. After creating a <b style='color: forestgreen;'>Custom Resource Definition (CRD)</b>, users can install it for testing. For deployment, packaging options like <b style='color: forestgreen;'>Helm</b> and <b style='color: forestgreen;'>Kustomize</b> help manage configuration variables for customizable deployments. <b style='color: forestgreen;'>Helm</b> acts as a package manager with reusable <b style='color: forestgreen;'>charts</b> for storage and installation, though its <b style='color: forestgreen;'>architecture</b> may pose <b style='color: forestgreen;'>security risks</b>. <b style='color: forestgreen;'>Kustomize</b>, on the other hand, offers <b style='color: forestgreen;'>declarative configurations</b> right from <b style='color: forestgreen;'>kubectl</b>, supporting <b style='color: forestgreen;'>variable customization</b> in manifests without altering the original file, making management easier."
        },
        {
            "title": "Custom API Servers: Flexibility Beyond CRDs",
            "body": "Custom <b style='color: forestgreen;'>API servers</b> offer an alternative to <b style='color: forestgreen;'>Custom Resource Definitions</b> (CRDs) and can overcome several of CRDs' limitations. These servers allow for more extensive control over Kubernetes' API surface and support customized storage options, like writing to a <b style='color: forestgreen;'>time series database</b> or supporting <b style='color: forestgreen;'>protobuf</b> serialization. Unlike CRDs, custom API servers can handle robust subresources and implement efficient resource <b style='color: forestgreen;'>operations</b> using Golang. They grant significant flexibility, especially useful when needing nuanced <b style='color: forestgreen;'>semantic implementation</b>, like <b style='color: forestgreen;'>graceful deletion</b> analogous to pods in Kubernetes."
        },
        {
            "title": "Registry and Strategy in Kubernetes",
            "body": "<h3 style='color: forestgreen;'>Key Points for ADHD/Dyslexia:</h3>\n\n- The generic <b style='color: forestgreen;'>registry</b> helps implement the <b style='color: forestgreen;'>default REST behavior</b> for most Kubernetes resources. It supports various operations like create, update, delete, and watch through a series of <b style='color: forestgreen;'>interfaces</b> like `Creater`, `Updater`, and `Watcher`. Admittedly, a registry implementing such interfaces will enable these API features automatically.\n\n- <b style='color: forestgreen;'>Verification</b> functions ensure API objects are validated after creation or update, maintaining consistency through recursive <b style='color: forestgreen;'>validation functions</b> (e.g., `ValidatePizza`). They provide error lists highlighting issues through <b style='color: forestgreen;'>field paths</b> in case of validation errors.\n\n- Setting up the <b style='color: forestgreen;'>REST logic</b> ties into defining strategies for operations like create or update, *including how names are generated or how objects are prepared before validation.* The strategy ensures that objects conform to API conventions."
        },
        {
            "title": "CRD Conversion Webhook Implementation",
            "body": "To implement <b style='color: forestgreen;'>CRD conversion</b>, we utilize a <b style='color: forestgreen;'>webhook server</b> in Kubernetes, allowing different API versions, like `v1alpha1` and `v1beta1`, to manage objects through a central conversion mechanism for stability and compatibility. We can create CRDs specifying these versions in a structured way, enabling translation across versions through a <b style='color: forestgreen;'>conversion webhook</b> that adjusts object representations before reaching <b style='color: forestgreen;'>etcd</b> or a client. This setup allows managing <b style='color: forestgreen;'>API changes</b> without disrupting existing systems. By configuring CRDs with conversion webhooks, Kubernetes can handle multiple API versions efficiently, maintaining backward compatibility while evolving the structure as needed."
        },
        {
            "title": "Advanced Kubernetes Customization and Management",
            "body": "The chunk continues the exploration of Kubernetes and APIs, focusing on the functionality and utility of admission webhooks and custom resource definitions (CRDs). It explains that admission webhooks, both validating and mutating, add more features to CRDs, bringing them closer to native Kubernetes resources and allowing for things like default values and dependency checks between resources. The importance of versioning and structural schemas is also highlighted. These schemas must adhere to certain rules to ensure Kubernetes API conventions are met. Structuring the API with these schemas enables future features like pruning and defaulting, while maintaining compatibility and offering improved resource manageability."
        }
    ]
}