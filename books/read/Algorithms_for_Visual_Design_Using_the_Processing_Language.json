{
    "meta": {
        "title": "Algorithms for Visual Design Using the Processing Language",
        "author": "Kostas Terzidis",
        "category": "Computer Science",
        "publisher": "Wiley",
        "pages": 385
    },
    "parts": [
        {
            "title": "Overview of the Book: Algorithms for Visual Design Using the Processing Language",
            "body": "<b style='color: forestgreen;'>Kostas Terzidis</b>, an architect and computer scientist, has authored <b style='color: forestgreen;'>Algorithms for Visual Design Using the Processing Language</b>. This book, published by <b style='color: forestgreen;'>Wiley Publishing</b>, explores the intersection of <b style='color: forestgreen;'>computational design</b> and architecture, and it offers foundational insights into the <b style='color: forestgreen;'>Processing programming language</b>. The table of contents outlines a structured approach to different concepts, beginning with basic <b style='color: forestgreen;'>language elements</b>, such as <b style='color: forestgreen;'>variables</b>, <b style='color: forestgreen;'>loops</b>, and <b style='color: forestgreen;'>graphics</b>. Subsequent chapters delve into <b style='color: forestgreen;'>advanced graphical methods</b>, <b style='color: forestgreen;'>3D space</b>, and *physical computing*, providing readers with comprehensive exercises to apply their learning effectively. This book bridges the gap between <b style='color: forestgreen;'>creative computing</b> and architecture, offering valuable resources for both <b style='color: forestgreen;'>novices and experts</b> in the field."
        },
        {
            "title": "Transformative Impact of Programming on Design",
            "body": "Technology has significantly transformed <b style='color: forestgreen;'>design</b> through programming, enabling designers to explore new creative avenues and solve problems without traditional constraints. Yet, this shift also raises questions about a designer's <b style='color: forestgreen;'>control</b> over their work. <b style='color: forestgreen;'>CAD</b> tools have become central, offering customization within limits, but programmers rarely share their <b style='color: forestgreen;'>source</b> codes due to proprietary reasons, thus confining creativity. Designers might leverage pre-defined processes, questioning whether they are truly creating something new or simply fulfilling a programmer's concept. The call for a <b style='color: forestgreen;'>Linux-like CAD community</b> hints at a need for open-source collaboration to unlock true design potential.\n\nThe integration of <b style='color: forestgreen;'>computational design</b> raises concerns and debates about its effect on the essence of design. While some view it as a loss of <b style='color: forestgreen;'>creativity</b> and control, others see it as a liberation from mundane tasks, enabling focus on core <b style='color: forestgreen;'>conceptualization</b>. The possibility of software capable of creating better designs autonomously further complicates this perspective, questioning the designer's role. Ultimately, the merging of <b style='color: forestgreen;'>design</b> and <b style='color: forestgreen;'>programming</b> is about adapting to a new era where tools become as crucial as creative intent, reshaping the future of design."
        },
        {
            "title": "Introduction to Processing Code Structure and Graphic Elements",
            "body": "In Processing, code is organized into two main sections: <b style='color: forestgreen;'>setup</b> and <b style='color: forestgreen;'>draw</b>. The <b style='color: forestgreen;'>setup()</b> function initializes things like screen size and initial properties, while the <b style='color: forestgreen;'>draw()</b> function runs repeatedly, allowing for animations and changes over time. Commands in Processing often include graphical elements like lines, rectangles, or ellipses, defined by their attributes (e.g., size, color).\n\nGeometrical objects such as <b style='color: forestgreen;'>point(x, y)</b>, <b style='color: forestgreen;'>line(x1, y1, x2, y2)</b>, <b style='color: forestgreen;'>rect(x, y, width, height)</b>, and <b style='color: forestgreen;'>ellipse(x, y, width, height)</b> are common. The command <b style='color: forestgreen;'>arc(x, y, width, height, start, stop)</b> draws a pie-shaped slice, while <b style='color: forestgreen;'>vertex()</b> helps create complex shapes. Visual attributes are manipulated using <b style='color: forestgreen;'>fill()</b>, <b style='color: forestgreen;'>noFill()</b>, <b style='color: forestgreen;'>stroke()</b>, and <b style='color: forestgreen;'>noStroke()</b>, which control color and line visibility."
        },
        {
            "title": "Understanding Recursion and Using Processing Classes",
            "body": "This section introduces <b style='color: forestgreen;'>recursion</b> with a focus on <b style='color: forestgreen;'>graphical and programmatic elements</b>. Recursion can effectively manage tasks requiring repeated actions, such as drawing <b style='color: forestgreen;'>nested geometric shapes</b> or calculating mathematical functions. An example provided illustrates creating concentric circles using a recursive algorithm in the <b style='color: forestgreen;'>Processing</b> programming environment. This approach simplifies the codebase by reusing the procedure within itself. Moreover, the technique lends itself to flexible manipulation of graphical elements in Processing, offering a straightforward means to generate detailed <b style='color: forestgreen;'>geometrical arrangements</b> with minimal code.\n\nBesides the basic recursion method, there's mention of how <b style='color: forestgreen;'>Processing</b> allows for importing various <b style='color: forestgreen;'>built-in classes</b> to extend functionality. This includes packages such as <b style='color: forestgreen;'>processing.net</b>, used for network communications, emphasizing the diverse application scope of Processing when augmented by these classes. Such structure makes it easier to build complex interactive or network-driven projects, demonstrating the flexibility and robustness of Processing as a creative coding framework."
        },
        {
            "title": "Creating Interactive and Responsive Polygons",
            "body": "The text describes <b style='color: forestgreen;'>responsive polygons</b> and how to make them interactive on a screen. Using programming methods, you can select and rearrange points visually. Two arrays, `px` and `py`, store x and y coordinates for the vertices of an <b style='color: forestgreen;'>equilateral polygon</b>. Within the `draw()` function, the shape is drawn, and rectangles are plotted at each vertex. Code checks if the <b style='color: forestgreen;'>mouse pointer</b> is close enough to a vertex; if it is, the rectangle's color changes to red, signaling interactivity.\n\nYou can also move these vertices interactively using the <b style='color: forestgreen;'>*mouseDragged()</b>* function. This function calculates the <b style='color: forestgreen;'>distance</b> from the mouse to each vertex, and if it finds a vertex within a 20-pixel range, it shifts the vertex using an <b style='color: forestgreen;'>offset</b>, making the vertex follow the mouse. Constraints are used to ensure <b style='color: forestgreen;'>vertices stay within the screen boundaries</b>. This approach provides a <b style='color: forestgreen;'>base for interactive design</b> and manipulation in geometric programming."
        },
        {
            "title": "Transformations and Matrices",
            "body": "To <b style='color: forestgreen;'>rotate objects</b> around a specific reference point, you follow a <b style='color: forestgreen;'>three-step</b> process: <b style='color: forestgreen;'>translate</b> the object to the origin by subtracting the reference point, perform the <b style='color: forestgreen;'>rotation</b> using sine and cosine functions, and then <b style='color: forestgreen;'>translate it back</b> to its original position. This method is coded in a function called <b style='color: forestgreen;'>rotate</b>. \n\n<b style='color: forestgreen;'>Matrices</b> can generalize these transformations, allowing more <b style='color: forestgreen;'>complex manipulations</b> of shapes. Once created, these basic <b style='color: forestgreen;'>transformation methods</b> are integrated into the <b style='color: forestgreen;'>MyPoint</b> class to enable the movement, rotation, and scaling of points in relation to a reference. Similarly, <b style='color: forestgreen;'>MySegment</b> and <b style='color: forestgreen;'>MyShape</b> classes incorporate these methods to perform transformations on segments and shapes, respectively, often using <b style='color: forestgreen;'>loops</b> to manage multiple parts. This organization enables building <b style='color: forestgreen;'>dynamic structures</b>, such as grids of shapes, effectively."
        },
        {
            "title": "Interacting with GUI Components and Bit Manipulation",
            "body": "The <b style='color: forestgreen;'>Java GUI framework</b> provides fundamental objects such as <b style='color: forestgreen;'>buttons</b>, <b style='color: forestgreen;'>labels</b>, <b style='color: forestgreen;'>text fields</b>, and more to create interactive interfaces. In this section, <b style='color: forestgreen;'>event listeners</b> were introduced to respond to user actions on GUI elements. For example, a <b style='color: forestgreen;'>button</b> can be configured to <b style='color: forestgreen;'>perform actions</b> such as executing a command on press, or a <b style='color: forestgreen;'>text field</b> can receive input which prompts a specific <b style='color: forestgreen;'>action on pressing enter</b>. Furthermore, a <b style='color: forestgreen;'>drop-down menu</b> (Choice) is explained, which enables users to select from multiple options, and its integration into GUI is detailed.\n\nThe section also covers the <b style='color: forestgreen;'>manual positioning and sizing</b> of GUI objects by nullifying the default layout settings, allowing greater <b style='color: forestgreen;'>customization</b> of the interface. <b style='color: forestgreen;'>Bit manipulation</b> is essential when dealing with pixel data, allowing direct modifications such as <b style='color: forestgreen;'>extracting colors</b> from images by dissecting the integer values that represent pixels. Efficient manipulation of these values is crucial in imagery tasks like <b style='color: forestgreen;'>changing colors</b> or applying filters, which are explored throughout the chapter."
        },
        {
            "title": "Creating Motion Effects through Animation Basics",
            "body": "This text covers implementing a motion effect using animation concepts where objects tremble or move based on random positions and user interactions. <b style='color: forestgreen;'>Animation basics</b> are explored with <b style='color: forestgreen;'>images</b> and <b style='color: forestgreen;'>geometric shapes</b>, by manipulating their position on the screen using a clock to simulate continuous motion, albeit a computer's clock operates many times faster than human perception. A practical example is given: a <b style='color: forestgreen;'>maple leaf</b> trembling over a background image by altering its <b style='color: forestgreen;'>x</b> and <b style='color: forestgreen;'>y</b> positions randomly, showing how different frame rates can affect perceived speed.\n\nThe <b style='color: forestgreen;'>image trembling</b> effect is expanded into multiple leaves that sway at different speeds by creating a class (named <b style='color: forestgreen;'>Leaf</b>) holding properties such as position and rate of motion. By defining an image object and utilizing a class constructor, each instance of a leaf is created with a random position. The <b style='color: forestgreen;'>rate property</b> is crucial here since it determines how often the leaf position is updated, thus affecting its speed. The described visuals and the program effectively give an autumn scene's realism with <b style='color: forestgreen;'>variance in speed</b> of different leaves on display, highlighting the balance between <b style='color: forestgreen;'>update rate</b> and <b style='color: forestgreen;'>perceived motion</b>."
        },
        {
            "title": "Voronoi Tessellations and Stochastic Searches",
            "body": "In order to create a <b style='color: forestgreen;'>Voronoi tessellation</b> on a grid, we keep track of the <b style='color: forestgreen;'>distances from marked points</b> to each grid point. By sorting the distances, we can color each area based on its closest mark, giving us a visual scatter of regions with unique colors representing proximity. If you want a clearer distinction between these areas, you can trace the <b style='color: forestgreen;'>edges</b> by identifying <b style='color: forestgreen;'>color differences</b> between neighboring pixels. Instead of keeping every area distinctly colored, this method results in precise <b style='color: forestgreen;'>black lines</b> highlighting the edges, effectively showing the tessellation's boundaries without the colors (see Figure 7-4).\n\nIn a <b style='color: forestgreen;'>stochastic search</b>, objects are randomly placed within a defined area ensuring <b style='color: forestgreen;'>no overlaps</b> with other objects. This randomness can simulate <b style='color: forestgreen;'>objects</b> or spaces (like patterns or storage) filling up fairly evenly. If there's no space for a new object after many tries, it breaks out to avoid an infinite loop. Additionally, we've seen an alternative where the placement extends from the <b style='color: forestgreen;'>last successful location</b>. This method results in clustering, generating <b style='color: forestgreen;'>snake-like</b> shapes as it explores available space. These techniques showcase how randomness can aid pattern formation and approximate <b style='color: forestgreen;'>task-solving</b> in computational design, offering diverse applications ranging from decoration to spatial planning."
        },
        {
            "title": "Defining and Transforming 3D Objects",
            "body": "In this section, the focus is on <b style='color: forestgreen;'>defining 3D objects</b> and extending <b style='color: forestgreen;'>2D transformations</b> (like move, scale, and rotate) to accommodate the <b style='color: forestgreen;'>third dimension</b>. To do this, a <b style='color: forestgreen;'>third coordinate</b> (z) is added to our previously defined points, enabling 3D spatial manipulation. For transformations:\n\n- <b style='color: forestgreen;'>Move</b> and <b style='color: forestgreen;'>scale</b> operations are enhanced by simply appending the extra z-dimension. \n- <b style='color: forestgreen;'>Rotation</b> undergoes more changes with added <b style='color: forestgreen;'>complexity</b> as it now includes <b style='color: forestgreen;'>three rotational axes (x, y, z)</b>. The method retains original 2D rotations (around the z-axis) and introduces rotations around the x-axis and y-axis, using <b style='color: forestgreen;'>trigonometric formulas</b> derived from coordinate transformations."
        },
        {
            "title": "Building 3D Objects from Points and Faces",
            "body": "In this <b style='color: forestgreen;'>section</b>, we're constructing <b style='color: forestgreen;'>3D</b> objects by combining smaller components like points and faces. We begin by creating a <b style='color: forestgreen;'>class called `MyPoint`</b> designed to store the <b style='color: forestgreen;'>coordinates</b> of a point in <b style='color: forestgreen;'>3D space</b>. This simple class holds the <b style='color: forestgreen;'>coordinates x, y, and z</b> and initializes them through a constructor.\n\nNext, we define a class called <b style='color: forestgreen;'>`MyFace`</b>, used to store information about a face in <b style='color: forestgreen;'>3D space</b>. A face is made up of an <b style='color: forestgreen;'>array of `MyPoint` objects</b>, allowing points to be added one at a time. This class includes a method `addPoint()` for adding points to the face, and a `plot()` method to visualize these faces using <b style='color: forestgreen;'>Processing's drawing capabilities</b>. The <b style='color: forestgreen;'>approach</b> outlined here allows the construction of complex 3D objects from simpler, basic geometrical components."
        },
        {
            "title": "Multiple Faces and Solid Class Construction",
            "body": "<h3 style='color: forestgreen;'>Sets of Faces</h3>\nTo <b style='color: forestgreen;'>draw multiple faces</b>, you can modify the `MyFace` class to accommodate <b style='color: forestgreen;'>two faces</b> into an array called `faces[]`. This involves creating one face and then moving another <b style='color: forestgreen;'>in the z direction</b>. The code example shows how to setup a P3D canvas and <b style='color: forestgreen;'>create two parallel planar polygons</b>, resulting in <b style='color: forestgreen;'>Figure 9-2</b> showcasing <b style='color: forestgreen;'>two parallel polygons</b>.\n\n<h3 style='color: forestgreen;'>Class MySolid</h3>\nThe `MySolid` class allows for the creation of <b style='color: forestgreen;'>solid objects</b> using extrusion. It accepts a <b style='color: forestgreen;'>base of points</b> and a <b style='color: forestgreen;'>height</b>, creating an extruded solid with <b style='color: forestgreen;'>top, bottom, and side faces</b>. The class uses <b style='color: forestgreen;'>cross product</b> to determine <b style='color: forestgreen;'>plane directions</b>. <b style='color: forestgreen;'>Figure 9-5</b> illustrates the result of these operations, modeling a basic <b style='color: forestgreen;'>3D cube.</b>"
        },
        {
            "title": "Handling Native and DXF File Formats",
            "body": "The <b style='color: forestgreen;'>native file format</b> we created allows the storage of 3D objects in a structured way, maintaining relationships like <b style='color: forestgreen;'>faces</b> and <b style='color: forestgreen;'>points</b>. When reading and writing these files, you handle each solid's data, writing out its <b style='color: forestgreen;'>number of faces</b> and <b style='color: forestgreen;'>points</b>, followed by the actual <b style='color: forestgreen;'>coordinates</b>. Conversely, when reading the file, you reconstruct the <b style='color: forestgreen;'>objects</b> by parsing this information. The key is simulatenously <b style='color: forestgreen;'>reading data</b> and constructing the data structures when loading files.\n\nProcessing also has built-in support for exporting graphics to formats like <b style='color: forestgreen;'>PDF</b> and <b style='color: forestgreen;'>DXF</b> using libraries. The <b style='color: forestgreen;'>DXF format</b> involves detailed code and vertex sequences to represent 3D objects as faces. Writing involves looped structures to map points to faces, while reading requires dynamic array expansion since the number of elements isn't pre-known. This modular design is like a <b style='color: forestgreen;'>butterfly hunter</b>, catching elements without knowing how many will be needed upfront."
        },
        {
            "title": "Summary of File Read/Write and Physical Computing Concepts",
            "body": "<b style='color: forestgreen;'>Physical computing</b> involves using physical devices like sensors and actuators to perform <b style='color: forestgreen;'>computational processes</b>. An Arduino microcontroller can connect to external inputs and outputs such as <b style='color: forestgreen;'>LEDs</b>, <b style='color: forestgreen;'>photo-resistors</b>, and more, allowing for the control of physical devices. \n\nTo create a simple circuit with <b style='color: forestgreen;'>Arduino</b>, you write code that defines actions using <b style='color: forestgreen;'>setup()</b> and <b style='color: forestgreen;'>loop()</b> functions. For example, turning an <b style='color: forestgreen;'>LED</b> on/off can be done by setting a pin to <b style='color: forestgreen;'>OUTPUT</b> using <b style='color: forestgreen;'>pinMode()</b> and controlling it with <b style='color: forestgreen;'>digitalWrite()</b>. You also learn to read data from a <b style='color: forestgreen;'>photo-resistor</b>, enabling visual feedback using <b style='color: forestgreen;'>serial communication</b> to a connected computer."
        },
        {
            "title": "Arduino Photocell and Servo Motor Feedback System",
            "body": "<b style='color: forestgreen;'>This section</b> of the <b style='color: forestgreen;'>text</b> introduces a <b style='color: forestgreen;'>program</b> for engaging in a <b style='color: forestgreen;'>feedback system</b> using both a <b style='color: forestgreen;'>photocell</b> and a <b style='color: forestgreen;'>servo motor</b> connected via Arduino. In this setup, the <b style='color: forestgreen;'>photocell</b> reads <b style='color: forestgreen;'>light intensity</b> and communicates this data to <b style='color: forestgreen;'>rotate the servo motor</b> at a specific angle based on the observed light changes. \n\nThe <b style='color: forestgreen;'>code</b> starts by setting pin <b style='color: forestgreen;'>13</b> to <b style='color: forestgreen;'>output mode</b>, reads data from the <b style='color: forestgreen;'>sensor</b> and uses this data to compute an angle to rotate the motor. The differential of the input sensor values guides the motor movement. The motor\u2019s <b style='color: forestgreen;'>angle</b> is first initialized at 90 and adjusts based on differentials assessed from the photocell. The motor engages through the <b style='color: forestgreen;'>servoMove()</b> function, using calculated values for <b style='color: forestgreen;'>pulse width</b> to delay the pulsing of the motor, thus influencing its rotation. Lastly, the text discusses how this setup becomes part of a simple <b style='color: forestgreen;'>feedback system</b> by creating a cycle where input affects output, and vice-versa, leading to a balance of input and output responses."
        },
        {
            "title": "Pattern and Graphic Algorithms",
            "body": "<b style='color: forestgreen;'>Pattern Algorithms</b>: The segment covers different <b style='color: forestgreen;'>pattern algorithms</b> showcasing how to produce unique <b style='color: forestgreen;'>graphic patterns</b> using <b style='color: forestgreen;'>Processing</b>. It illustrates algorithmic procedures for generating graphics that scale, <b style='color: forestgreen;'>rotate</b>, and <b style='color: forestgreen;'>transform</b> periodically - showcasing patterns like rotating rectangles and evolving graphics based on <b style='color: forestgreen;'>user interaction</b>. The commands are structured to translate and rotate graphics to specific positions and orientations.\n\n<b style='color: forestgreen;'>Graphic Processing Adjustments</b>: Through <b style='color: forestgreen;'>functions like void setup()</b> and <b style='color: forestgreen;'>draw()</b>, patterns are dynamically adapted, allowing different transformations using <b style='color: forestgreen;'>mouse inputs</b> for scale and rotation, enhancing <b style='color: forestgreen;'>interactive designs</b>. Additionally, methods are introduced to handle transformations and motions elegantly, fostering complex graphical designs adaptable based on <b style='color: forestgreen;'>user inputs</b> and <b style='color: forestgreen;'>environmental factors</b> like <b style='color: forestgreen;'>time</b> or <b style='color: forestgreen;'>mouse position</b>."
        }
    ]
}